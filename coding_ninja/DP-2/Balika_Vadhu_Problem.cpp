/*
 Balika Vadhu- Problem
Send Feedback
Anandi and Jagya were getting married again when they have achieved proper age. Dadi Sa 
invited Alok Nath to do the kanyadaan and give blessings. Alok Nath has 2 blessings. Each
 bessing is in the form of a string consisting of lowercase charaters(a-z) only. But he can
  give only one blessing of K length because some priest told him to do so. Thus he decides
   to generate a blessing using the other two blessings. While doing this he wants to ensure that 
   happiness brought into their life by his blessing is maximum.
The generated blessing is a common subsequence of length K of the two blessings he has. Happiness of 
the blessing he generates is calculated by the sum of ASCII values of characters in the blessing and
 he wants the happiness to be maximum. If he is not able to generate a common subsequence of length K
  then the happiness is 0 (zero). Alok Nath comes to you and asks you to find the maximum happiness that
   can be generated by the two blessings he has.
Input Specification

First line consists of number of test cases t. Each test case consists of two strings b1 (blessing 1),b2 (blessing 2) 
and an integer K, each of them in separate lines.

Output Specification

Output consists of t lines each containing an integer denoting the maximum happiness value that can be generated by the
 two blessings.

Constraint

1 <= t <= 50

1 <= length(b1) , length(b2) <= 100 

1 <= K <= 100

Sample Input

2
asdf
asdf
3
anandi
jagya
3

Sample Output

317
0


*/
#include<bits/stdc++.h>
using namespace std;
#define ll long long int
#define MOD 1000000007
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    ll t,k;
    cin>>t;
    while(t--)
    {
        string s1,s2;
        cin>>s1>>s2;
        cin>>k;
        ll m=s1.length();
        ll n=s2.length();
        ll dp[m+1][n+1][k+1];
        // ll dp1[m+1][n+1];
        // for(ll i=0;i<=m;i++)
        // {
        //     for(ll j=0;j<=n;j++)
        //     {
        //         dp1[i][j]=0;
        //     }
        // }
//         for(ll i=1;i<=m;i++)
//         {
//             for(ll j=1;j<=n;j++)
//             {
//                 if(s1[m-i]==s2[n-j])
//                 dp1[i][j]=1+dp1[i-1][j-1];
//                 else
//                 {
//                     dp1[i][j]=max(dp1[i-1][j],dp1[i][j-1]);
//                 }

//             }
//         }
//     	ll lis=dp1[m][n];
        for(ll i=0;i<=m;i++)
        {
            for(ll j=0;j<=n;j++)
            {
                for(ll l=0;l<=k;l++)
                {
                    dp[i][j][l]=0;
                }
                
            }
        }
        for(ll i=1;i<=m;i++)
        {
            for(ll j=1;j<=n;j++)
            {
                for(ll l=1;l<=k;l++)
                {
                    if(s1[m-i]==s2[n-j])
                    {
                        ll prev=dp[i-1][j-1][l-1];
                        if(prev==0 && l!=1)
                            dp[i][j][l]=max(dp[i-1][j][l],dp[i][j-1][l]);
                        else
                    dp[i][j][l]=max(s1[m-i]+dp[i-1][j-1][l-1],max(dp[i-1][j][l],dp[i][j-1][l]));
                        // cout<<dp[i][j][l]<<" dp[i][j][l] "<<i<<" i "<<j<<" j "<<l<<" l "<<" if "<<endl;
                      
                    }
                    else
                    {
                        dp[i][j][l]=max(dp[i-1][j][l],dp[i][j-1][l]);
                        // cout<<dp[i][j][l]<<" dp[i][j][l] "<<i<<" i "<<j<<" j "<<l<<" l "<<" else "<<endl;
                    }
                }
            }
        }
        // if(lis>=k)
        cout<<dp[m][n][k]<<endl;
        // else
            // cout<<0<<endl;

    }
    
    
}
